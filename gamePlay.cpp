/**************************************************************************************************************
** Program name:  Prey-Predator Group #19 Project
** Author:  Issac J Thornton
** Date:  10 May 2018
** Description: Specification class, GamePlay.cpp, that uses cellular automata to create a 2D predator–prey
** simulation in your program.  The preys are ants and the predators are doodlebugs.
**
** 1.  Initialize the world with 5 doodlebugs and 100 ants; randomly place them on the grid.
** 2.  Prompt the user to enter the number of time steps to run.
** 3.  For each time step, do the following in your program: after moves, when breeding, eating, and starving are
**     resolved, display the resulting grid.
** 4.  Draw the world using ASCII characters of “O” for an ant, “X” for a doodlebug and blank space for an empty
**     space (the characters should be arranged to look like a grid). The doodlebugs will move before the ants in
**     each time step.
** 5.  When you reach the time steps entered by the user, ask them to enter another number and start to run the
**     simulation again or to exit the program. You must maintain the state of the current grid while creating
**     the next display.
** 6.  You should use a dynamic array to represent the grid.  Each array element will be a pointer to a Critter.
***************************************************************************************************************/
#include <iostream>
#include <stdlib.h>
#include <time.h>//needed for random seed, generated by system clock

#include "GamePlay.hpp"
#include "Ant.hpp"
#include "Doodlebug.hpp"

#define DIM 20//row and column dimension for gameGrid

const char ant = 'O';
const char doodlebug = 'X';
const char space = ' ';

  //constructor
  GamePlay::GamePlay(Critter** grid,int steps)
  {
    gameGrid=grid;//initialized by constructor
    simSteps=steps;//initialized by constructor

    srand(time(NULL));//initialize random seed with computer system time
  }

  /************************************************************************
  ** after moves, when breeding, eating, and starving are resolved, display
  ** the resulting grid. Draw the world using ASCII characters of “O”
  ** for an ant, “X” for a doodlebug and blank space for an empty space
  ************************************************************************/
  void GamePlay::displayGrid()
  {
    int i,j;
    char species;
    Critter* gridCritter;

    for(i=0;i<DIM;i++)
     {
       std::cout << " __ ";
     }

      std::cout<<"\n\n";


      for(i=0;i<DIM;i++)
         {
           for(j=0;j<DIM;j++)
              {
                //determine species
                gridCritter=*(gameGrid+i)+j;

                if(gridCritter==NULL)
                  {
                    species=space;
                  }
                else if(gridCritter->getSpecies()=='O')
                  {
                    species=ant;
                  }
                else if(gridCritter->getSpecies()=='X')
                  {
                    species=doodlebug;
                  }

                //print species character
                if(j==0)
                 {
                   std::cout << "| ";
                   std::cout << species << " | ";
                 }

                else
                 {
                   std::cout << species << " | ";
                 }

              }

           std::cout<<"\n";

         }

      for(i=0;i<DIM;i++)
         {
           std::cout << " __ ";
         }

      std::cout<<"\n";

  }

  /**********************************************************
  **Initialize the world with 5 doodlebugs and 100 ants.
  **You will randomly place them on the grid.
  **********************************************************/
  void GamePlay::initializeGrid()
  {
    int row,col;
    Critter* crit_init;

    //initialize 5 doodlebugs
    for(int i=0;i<4;i++)
    {
        do
        {
         row=(rand() % DIM);//DIM = 20; result = (0,19)
         col=(rand() % DIM);//DIM = 20; result = (0,19)

         crit_init=*(gameGrid+row)+col;
        }while(crit_init!=NULL);

        *crit_init=Doodlebug();//assign Doodlebug object to grid
    }
    std::cout<<"\n5 Doodelbugs initialized\n";


    //initialize 5 doodlebugs
    for(int i=0;i<100;i++)
    {
        do
        {
         row=(rand() % DIM);//DIM = 20; result = (0,19)
         col=(rand() % DIM);//DIM = 20; result = (0,19)

         crit_init=*(gameGrid+row)+col;
        }while(crit_init!=NULL);

        *crit_init=Ant();//assign Ant object to grid
    }
    std::cout<<"\n100 Ants initialized\n";

  }

  /***************************************************************
  **move all doodlebugs before any ant is moved for each time step
  ***************************************************************/
  void GamePlay::stepDoodleBugs()
  {
    int i,j;
    Critter* gridCrit;

    for(i=0;i<DIM;i++)
         {
           for(j=0;j<DIM;j++)
              {
                //determine species
                gridCrit=*(gameGrid+i)+j;

                if(gridCrit==NULL||gridCrit->getSpecies()=='O')
                  {
                    break;//do nothing if not doodlebug
                  }
                else if(gridCrit->getSpecies()=='X')
                  {
                    gridCrit->moveCritter();
                    //determine to breed, starve
                  }
              }

         }



  }

  /***************************************************************
  **move all doodlebugs before any ant is moved for each time step
  ***************************************************************/
  void GamePlay::stepAnts()
  {
    int i,j;
    Critter* gridCrit;

    for(i=0;i<DIM;i++)
         {
           for(j=0;j<DIM;j++)
              {
                //determine species
                gridCrit=*(gameGrid+i)+j;

                if(gridCrit==NULL||gridCrit->getSpecies()=='X')
                  {
                    break;//do nothing if not ant
                  }
                else if(gridCrit->getSpecies()=='O')
                  {
                    gridCrit->moveCritter();
                    //determine to breed
                  }
              }

         }

  }


